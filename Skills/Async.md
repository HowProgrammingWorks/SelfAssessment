## Asynchronous programming

- Theory
  - Event loopğŸ™‹
  - try..catchğŸ“
  - Non-blockingğŸ–ï¸
  - Async I/OğŸ–ï¸
  - Thread poolğŸ‘‚
  - Pattern ReactorğŸ‘‚
  - CAS operationsğŸ‘‚
  - epollğŸ‘‚
  - kqueueğŸ‘‚
  - Completion portsğŸ‘‚
  - Event portsğŸ‘‚
  - libuvğŸ‘‚
  - Race conditions
  - Dead locksğŸ–ï¸
  - Live locksğŸ–ï¸
  - Concurrent programmingğŸ‘‚
  - Parallel programmingğŸ‘‚
  - Actor Model
  - ThreadğŸ‘‚
  - ProcessğŸ–ï¸
- Async contracts
  - CallbacksğŸ“
  - Callback-last-error-firstğŸ“
  - ThenableğŸ–ï¸
  - PromiseğŸ‘‚
  - Async/awaitğŸ–ï¸
  - FutureğŸ‘‚
  - DeferredğŸ‘‚
  - Sync generatorğŸ“
  - Async GeneratorğŸ‘‚
  - Async IteratorğŸ‘‚
  - EventğŸ“
  - CoroutineğŸ‘‚
  - GoroutineğŸ‘‚
  - SignalğŸ‘‚
  - StreamğŸ“
  - Chain of responsibilityğŸ‘‚
  - MiddlewareğŸ‘‚
  - Locks ğŸ™‹
- Async adapters and utils
  - callbackifyğŸ–ï¸
  - promisify ğŸ“
  - asyncifyğŸ–ï¸
  - callbacks composeğŸ–ï¸
  - async compose ğŸ“
- Async abstractions interfaces
  - EventEmitter ğŸ“
  - Observable/Observer ğŸ“
  - Readable ğŸ“
  - Writable ğŸ“
  - Transform ğŸ“
  - Async Pool ğŸ“
  - Async Queue ğŸ“
  - Async Collector ğŸ“
  - Semaphore ğŸ“
  - Mutex ğŸ“
  - Spin Lock ğŸ“
- JavaScript & Node.js specific
  - Timers ğŸ“
  - setImmediate ğŸ“
  - nextTick ğŸ“ 
  - AbortController ğŸ“
  - AbortSignal ğŸ“
  - Promise unhandled rejection ğŸ“
  - Promise double resolve ğŸ“
  - child_process ğŸ“
  - worker_threads ğŸ“
  - Atomics ğŸ“
  - High resolution clock ğŸ“
  - Callback hell ğŸ“
  - Promise hell ğŸ“
  - ref() and unref() ğŸ“
  - Error handling in async code ğŸ“
  - Better stack traces with return await ğŸ“
  - JSON: streaming serialization ğŸ“
  - promisify ğŸ“
  - callbackify ğŸ“
  - AsyncLocalStorage ğŸ“
  - AsyncResource ğŸ“
- Techniques
  - async.js library ğŸ“
  - RxJS library ğŸ“
  - Async composition ğŸ“
  - Promise.all ğŸ“
  - Promise.allSettled ğŸ“
  - Promise.race ğŸ“
  - Promise.any ğŸ“
  - Web Locks API ğŸ“
  - IPC ğŸ“
  - Channel API ğŸ“
  - Revealing Constructor ğŸ“
  - Web Locks API ğŸ“
